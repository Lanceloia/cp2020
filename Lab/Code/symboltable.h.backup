#ifndef SYMBOLTABLE_H
#define SYMBOLTABLE_H

#include "lexical_syntax.h"

typedef struct Type Type;
typedef struct FieldList FieldList;
typedef struct Structure Structure;
typedef struct Function Function;
typedef struct Symbol Symbol;

typedef struct SymbolBucket SymbolBucket;
typedef struct SymtabStk SymtabStk;

extern void initSymtab();
extern void createSymtab();
extern void dropSymtab();
extern void insertSymtab(Symbol* sb);
extern void querySymtab(Symbol* ans_sb);
extern FieldList* buildFieldListFromSymtab();
extern void dropFieldListAfterPush(FieldList* fl);
extern void showSymtab();

/* 接口 */
int type_equal(const Type* t1, const Type* t2);
int symbol_kind_equal(const Symbol* sb1, const Symbol* sb2);

// 变量的类型
struct Type {
  enum { _UNKNOWN, _INT, _FLOAT, _ARRAY, _STRUCTURE } kind;
  union {
    struct {
      Type* type;
      int size;       // 数组的大小
      int dimension;  //数组的维度
    } array;
    struct {
      FieldList* field;
    } structure;
  };
  char typename[MAX_NAME_LEN];
};

// 结构体名的类型
struct Structure {
  FieldList* field;
};

// 函数名的类型
struct Function {
  Type ret_type;
  FieldList* parameter;
};

//  符号的类型
struct Symbol {
  enum { _VARIABLE, _STRUCT_NAME, _FUNCTION_NAME } kind;
  union {
    struct {
      Type type;
    } variable;
    Structure structure;
    Function function;
  };
  char symname[MAX_NAME_LEN];
  enum { UNDEFINE, DECLARATION, DEFINITION } dec;
  int dec_lineno;
  // 在symtab_g中，nextsymbol指上一个同名的符号，其作用域被该符号覆盖
  // 在symtab_l中，nextsymbol指下一个不同名的符号，其作用域与该符号相同
  Symbol* nextsymbol;
};

// 域
struct FieldList {
  Symbol var;
  FieldList* next;
};

#endif