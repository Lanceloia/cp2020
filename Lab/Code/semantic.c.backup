#include "semantic.h"

#include "assert.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

typedef struct Type Type;
typedef struct Symbol Symbol;

void semantic_error(int error_type, int lineno, char* msg, char* msg2);

void Program(struct ast* node) {
  // 初始化全局符号表
  initSymtab();
  // 创建最底层的局部符号表（作用域也为全局）
  // 遇到结构体/函数的声明则将其记录
  // 遇到结构体/函数的定义则将原有声明覆盖
  // 变量只能定义不能声明，重复的全局变量均视为错误
  createSymtab();
  // 开始进行文法分析
  ExtDefList(node->children[0]);
  // 删除最底层的局部符号表
  // 依次检查各个符号，如果某个符号只有声明没有定义则视为错误
  dropSymtab();
}

void ExtDefList(struct ast* node) {
  if (node->num == -1)
    // ExtDefList -> epsilon
    return;
  // ExtDefList -> ExtDef ExtDefList
  ExtDef(node->children[0]);      // ExtDef
  ExtDefList(node->children[1]);  // ExtDefList
}

void ExtDef(struct ast* node) {
  Type type;
  // Specifier识别出type的内容
  Specifier(node->children[0], &type);
  // printf("typename: %s\n", type.typename);
  if (!strcmp(node->children[1]->name, "ExtDecList")) {
    // ExtDef -> Specifier ExtDecList SEMI
    // 全局变量的定义
    ExtDecList(node->children[1], &type);
  }
  // ExtDef -> Specifier SEMI
  // 结构体类型的的定义/声明
  else if (!strcmp(node->children[1]->name, "SEMI")) {
    // 检查结构体是否存在冲突定义/声明
    // 这个specifier可能会变成int？我不知道哦
    assert(type.kind == _STRUCTURE);
    // puts("Ext -> Specifier SEMI\n");
  } else {
    Symbol func;
    func.kind = _FUNCTION_NAME;
    func.function.ret_type = type;
    func.dec_lineno = node->lineno;
    if (!strcmp(node->children[2]->name, "SEMI")) {
      // ExtDef -> Specifier FunDec SEMI
      func.dec = DECLARATION;
      FunDec(node->children[1], &func);
      insertSymtab(&func);
    } else {
      // ExtDef -> Specifier FunDec CompSt
      func.dec = DEFINITION;
      FunDec(node->children[1], &func);
      insertSymtab(&func);
      createSymtab();
      FieldList* parameter = func.function.parameter;
      while (parameter) {
        insertSymtab(&parameter->var);
        parameter = parameter->next;
      }
      CompSt(node->children[2], &type);
      dropSymtab();
    }
  }
}

void ExtDecList(struct ast* node, const Type* type) {
  if (node->num == 1) {
    // ExtDecList -> VarDec
    // 通过继承属性type来形成变量的定义
    VarDec(node->children[0], type, DEFINITION);
  } else {
    // ExtDecList -> VarDec COMMA ExtDecList
    VarDec(node->children[0], type, DEFINITION);
    ExtDecList(node->children[2], type);
  }
}

void Specifier(struct ast* node, Type* type) {
  if (!strcmp(node->children[0]->name, "TYPE")) {
    // Specifier -> TYPE
    if (!strcmp(node->children[0]->id_name, "int")) {
      type->kind = _INT;
      strcpy(type->typename, "int");
    } else {
      type->kind = _FLOAT;
      strcpy(type->typename, "float");
    }
  } else if (!strcmp(node->children[0]->name, "StructSpecifier")) {
    // Specifier -> StructSpecifier
    // 转交给StructSpecifier来填充type
    type->kind = _STRUCTURE;
    StructSpecifier(node->children[0], type);
  }
  // 完成了对type的填写
  // printf("typename2: %s\n", type->typename);
}

void StructSpecifier(struct ast* node, Type* type) {
  // sb的kind是variable，对应的type.kind是structure
  assert(type->kind == _STRUCTURE);
  Symbol ss;  // StructSpecifier
  if (!strcmp(node->children[1]->name, "OptTag")) {
    // StructSpecifier -> STRUCT OptTag LC DefList RC
    // OptTag过程确定structure A{int var;}中的A，A可以是匿名
    // 注意要在OptTag处记录这个structure的name
    // 建立起structure.name->fieldlist的映射关系
    OptTag(node->children[1], &ss);
    strcpy(type->typename, "struct ");
    strcat(type->typename, ss.symname);
    //此处类型为结构体类型
    // 检查是否有重复
    querySymtab(&ss);
    if (ss.dec == DEFINITION)
      semantic_error(16, node->lineno, ss.symname, NULL);
    // 将structure的kind设置为struct_name
    ss.kind = _STRUCT_NAME;
    // 有LC和RC的StructSpecifier是definition
    ss.dec = DEFINITION;
    // 记录下新定义的struct A
    insertSymtab(&ss);
    // 填写A的域
    // LC: 创建新的局部符号表，用于定义域变量
    createSymtab();
    // DefList将括号中的内容提取到最新的局部符号表
    DefList(node->children[3]);
    // 将局部符号表的符号填入sb中
    // 填充sb->structure.fieldlist
    ss.structure.field = buildFieldListFromSymtab();
    // RC: 删除刚才创建的局部符号表
    dropSymtab();

    type->structure.field = ss.structure.field;
  } else {
    // StructSpecifier -> STRUCT Tag
    // 使用之前在OptTag中创建的非匿名结构体
    // 曾经建立了struct.name->fieldlist的映射关系
    // 使用Tag过程找到OptTag定义的fieldlist，将其载入type
    Tag(node->children[1], &ss);
    strcpy(type->typename, "struct ");
    strcat(type->typename, ss.symname);
    // 检查是否有ss.symname对应的fieldlist
    // 如果有，将其填入type中
    // 如果没有，报错：结构体struct.name未定义
    Symbol ans_sb;
    strcpy(ans_sb.symname, ss.symname);
    querySymtab(&ans_sb);
    if (ans_sb.dec == UNDEFINE) {
      semantic_error(17, node->lineno, ss.symname, NULL);
      type->structure.field = NULL;
    } else
      type->structure.field = ans_sb.structure.field;
  }
}

void OptTag(struct ast* node, Symbol* sb) {
  // 功能在上文中提及了
  // OptTag只能变为终结符ID或者空串
  /* 这是为了支持struct a和a不重名的代码
  char name[MAX_NAME_LEN] = "struct ";
  if (node->num != -1)
    // 变为ID的情形下
    ID(node->children[0], sb);
  else
    // 变为空串的情形下
    strcpy(sb->symname, "unname struct ");
  strcat(name, sb->symname);
  strcpy(sb->symname, name);
  */
  static int unname_cnt = 0;
  if (node->num != -1)
    // 变为ID的情形下
    ID(node->children[0], sb);
  else
    // 变为空串的情形下
    sprintf(sb->symname, "unname(%d)", unname_cnt++);
}

void Tag(struct ast* node, Symbol* sb) {
  // 功能在上文中提及了
  // Tag只能变为终结符ID
  ID(node->children[0], sb);
}

void FunDec(struct ast* node, Symbol* func) {
  assert(func->kind == _FUNCTION_NAME);
  assert(func->dec != UNDEFINE);
  // func->symname由ID填写
  ID(node->children[0], func);
  // 函数的参数的作用域为局部，创建新的符号表
  createSymtab();
  if (node->num == 4) {
    // FunDec -> ID LP VarList RP
    VarList(node->children[2]);
    func->function.parameter = buildFieldListFromSymtab();
  } else {
    // FunDec -> ID LP RP
    func->function.parameter = NULL;
  }
  dropSymtab();
}

void VarList(struct ast* node) {
  if (node->num == 1)
    // VarList -> ParamDec
    ParamDec(node->children[0]);
  else {
    // VarList -> ParamDec COMMA VarList
    ParamDec(node->children[0]);
    VarList(node->children[2]);
  }
}

void ParamDec(struct ast* node) {
  // ParamDec -> Specifier VarDec
  Type type;
  Specifier(node->children[0], &type);
  VarDec(node->children[1], &type, DEFINITION);
}

void CompSt(struct ast* node, const Type* ret_type) {
  // CompSt -> LC DefList StmtList RC
  // LC: 局部作用域开始F
  createSymtab();
  // DefList: 局部变量定义语句
  DefList(node->children[1]);
  // StmtList: 陈述句
  StmtList(node->children[2], ret_type);
  // RC: 局部作用域结束
  dropSymtab();
}

void DefList(struct ast* node) {
  if (node->num == -1)
    // DefList -> empty
    return;
  // DefList -> Def DefList
  // 递归地调用自身，逐句处理局部变量的定义语句
  Def(node->children[0]);
  DefList(node->children[1]);
}

void Def(struct ast* node) {
  // Def -> Specifier DecList SEMI
  Type type;
  // Specifier再次出场，填写type
  Specifier(node->children[0], &type);
  // 强声明（definition）
  // DecList使用sb作为继承属性，完成局部变量的定义
  DecList(node->children[1], &type, DEFINITION);
  // SEMI
}

void DecList(struct ast* node, const Type* type, const int dec) {
  if (node->num == 1) {
    // DecList -> Dec
    // 一次只定义一个类型为type的变量
    Dec(node->children[0], type, dec);
  } else {
    // DecList -> Dec COMMA DecList
    // 递归调用自己，完成处理
    Dec(node->children[0], type, dec);
    DecList(node->children[2], type, dec);
  }
}

void Dec(struct ast* node, const Type* type, const int dec) {
  if (node->num == 1)
    //  Dec -> VarDec
    VarDec(node->children[0], type, dec);
  else {
    // Dec -> VarDec ASSIGNOP Exp
    VarDec(node->children[0], type, dec);
    Type exp_type;
    // Exp过程计算出表达式的类型，填写在exp_type中
    Exp(node->children[2], &exp_type);
    // 判定二者类型是否相容
    if (!type_equal(type, &exp_type))
      // 报错
      assert(0);
  }
}

void VarDec(struct ast* node, const Type* type, const int dec) {
  if (node->num == 1) {
    Symbol symbol;
    // VarDec -> ID
    symbol.kind = _VARIABLE;
    // 这一句会有问题，因为type中可能存在指针内容，要完全拷贝
    if (type->kind != _ARRAY)
      symbol.variable.type = *type;
    else {
      Type* cur = &symbol.variable.type;
      while (type->kind == _ARRAY) {
        cur->kind = type->kind;
        strcpy(cur->typename, type->typename);
        cur->array.dimension = type->array.dimension;
        cur->array.size = type->array.size;
        type = type->array.type;
        cur->array.type = malloc(sizeof(Type));
        cur = cur->array.type;
      }
      // 基类型
      *cur = *type;
    }
    ID(node->children[0], &symbol);
    symbol.dec = dec;
    symbol.dec_lineno = node->lineno;
    assert(symbol.dec == DEFINITION);
    insertSymtab(&symbol);
  } else {
    // VarDec -> VarDec LB INT RB
    int size = node->children[2]->int_value;
    // 将symbol改写成数组的形式
    // 为了将const Type*转为Type*
    Type array_type, consttype = *type;
    array_type.kind = _ARRAY;
    array_type.array.type = &consttype;
    array_type.array.size = size;
    strcpy(array_type.typename, type->typename);
    strcat(array_type.typename, " *");
    if (type->kind == _ARRAY)
      array_type.array.dimension = type->array.dimension + 1;
    else
      array_type.array.dimension = 1;
    // 递归调用自己以创建高维数组
    VarDec(node->children[0], &array_type, dec);
  }
}

void StmtList(struct ast* node, const Type* ret_type) {
  if (node->num == -1)
    // StmtList -> empty
    return;
  // StmtList -> Stmt StmtList
  Stmt(node->children[0], ret_type);
  StmtList(node->children[1], ret_type);
}

void Stmt(struct ast* node, const Type* ret_type) {
  // puts("Stmt");
  Type exp_type;
  if (!strcmp(node->children[0]->name, "Exp")) {
    // Stmt -> Exp SEMI
    Exp(node->children[0], &exp_type);
  } else if (!strcmp(node->children[0]->name, "RETURN")) {
    // Stmt -> RETURN Exp SEMI
    // 这里需要判断RETURN的类型和函数是否相容
    Exp(node->children[1], &exp_type);
    if (!type_equal(ret_type, &exp_type))
      semantic_error(8, node->lineno, NULL, NULL);
  } else if (!strcmp(node->children[0]->name, "IF")) {
    if (node->num == 5) {
      // Stmt -> IF LP Exp RP Stmt
      // 这里需要检查Exp的类型是否为int型
      Exp(node->children[2], &exp_type);
      Stmt(node->children[4], ret_type);
    } else if (node->num == 7) {
      // Stmt -> IF LP Exp RP Stmt ELSE Stmt
      // 这里需要检查Exp的类型是否为int型
      Exp(node->children[2], &exp_type);
      Stmt(node->children[4], ret_type);
      Stmt(node->children[6], ret_type);
    }
  } else if (!strcmp(node->children[0]->name, "WHILE")) {
    // Stmt -> WHILE LP Exp RP Stmt
    // 这里需要检查Exp的类型是否为int型
    Exp(node->children[2], &exp_type);
    Stmt(node->children[4], ret_type);
  }
}

int Exp(struct ast* node, Type* left_type) {
  // val_type是需要填写的
  // 一堆算式，检查类型是否为可以运算的类型
  // 是否同为int或者同为float相等，数组中间的表达式需要为int
  // 函数调用要求ID是函数名
  // 函数调用要求参数数量与等等
  // 返回值表示Exp能否为左值
  // 表达式的类型等于最左子表达式的类型
  // puts("Exp");

  if (node->num == 3 && !strcmp(node->children[0]->name, "Exp") &&
      !strcmp(node->children[2]->name, "Exp")) {
    Type right_type;
    int left_ret;
    left_ret = Exp(node->children[0], left_type);
    Exp(node->children[2], &right_type);
    // 当左值的类型出错时，（可以）认为左值应该与右值类型相同
    // if (left_type->kind == _UNKNOWN) left_type->kind = right_type.kind;

    if (!strcmp(node->children[1]->name, "ASSIGNOP")) {
      // 当赋值号左右的类型不相等时
      if (!type_equal(left_type, &right_type))
        semantic_error(5, node->lineno, NULL, NULL);
      // 当赋值运算符的左边是不是左值
      if (!left_ret) semantic_error(6, node->lineno, NULL, NULL);
    } else {
      // 当非赋值运算符的操作数类型不相等时
      if (!type_equal(left_type, &right_type))
        semantic_error(7, node->lineno, NULL, NULL);
    }
    // 整条语句并非左值
    return 0;
  } else if (node->num == 2 && (!strcmp(node->children[0]->name, "LP") ||
                                !strcmp(node->children[0]->name, "MINUS") ||
                                !strcmp(node->children[0]->name, "NOT"))) {
    Exp(node->children[1], left_type);
    // 并非左值
    return 0;
  } else if (node->num > 2 && !strcmp(node->children[0]->name, "ID") &&
             !strcmp(node->children[1]->name, "LP")) {
    // 函数调用
    Symbol ans_sb;
    ID(node->children[0], &ans_sb);
    querySymtab(&ans_sb);
    if (ans_sb.dec == UNDEFINE)
      semantic_error(2, node->lineno, ans_sb.symname, NULL);
    else if (ans_sb.kind != _FUNCTION_NAME)
      semantic_error(11, node->lineno, ans_sb.symname, NULL);
    else {
      if (node->num == 4) {
        // 有参数的函数，判断参数是否类型匹配
        Args(node->children[2], ans_sb.function.parameter);
      } else if (node->num == 3) {
        // 无参数的函数
        assert(ans_sb.function.parameter == NULL);
      }
      // 并非左值
      return 0;
    }
  } else if (node->num == 4 && !strcmp(node->children[1]->name, "LB") &&
             !strcmp(node->children[3]->name, "RB")) {
    // Exp -> Exp LB Exp RB
    // 数组
    Type father_type, integer_type;
    Exp(node->children[0], &father_type);
    Exp(node->children[2], &integer_type);
    if (integer_type.kind != _INT) {
      struct ast* child = node->children[2];
      char msg[32];
      if (child->num == 1 && !strcmp(child->children[0]->name, "FLOAT")) {
        sprintf(msg, "%g", child->children[0]->float_value);
        semantic_error(12, node->lineno, msg, NULL);
      } else
        semantic_error(12, node->lineno, NULL, NULL);
    }
    if (father_type.kind == _ARRAY) {
      if (father_type.array.type != NULL) {
        *left_type = *father_type.array.type;
        // assert(left_type->kind == _ARRAY);
        // assert不成立表示维度过高
      }
    } else {
      struct ast* child = node->children[0];
      if (child->num == 1 && !strcmp(child->children[0]->name, "ID"))
        semantic_error(10, node->lineno, child->children[0]->id_name, NULL);
      else
        semantic_error(10, node->lineno, NULL, NULL);
    }
    // 左值
    return 1;
  } else if (node->num == 3 && !strcmp(node->children[1]->name, "DOT")) {
    // 域变量访问
    Symbol fieldVar;
    Type structType;
    Exp(node->children[0], &structType);
    assert(structType.kind == _STRUCTURE);
    ID(node->children[2], &fieldVar);
    if (structType.kind != _STRUCTURE)
      semantic_error(13, node->lineno, NULL, NULL);
    else {
      FieldList* fl = structType.structure.field;
      while (fl) {
        d(1);
        if (!strcmp(fl->var.symname, fieldVar.symname)) break;
        fl = fl->next;
      }
      if (fl == NULL) semantic_error(14, node->lineno, fieldVar.symname, NULL);
    }
    return 1;
  } else if (!strcmp(node->children[0]->name, "ID") && node->num == 1) {
    // 标示符
    Symbol ans_sb;
    ID(node->children[0], &ans_sb);
    querySymtab(&ans_sb);

    printf("name: %s, kind: %d\n", ans_sb.symname, ans_sb.kind);
    if (ans_sb.dec == UNDEFINE)
      semantic_error(1, node->lineno, node->children[0]->id_name, NULL);
    else {
      assert(ans_sb.kind == _VARIABLE);
      *left_type = ans_sb.variable.type;
    }
    // 未定义的标示符也当作标示符，视为左值
    printf("kind %d\n", left_type->kind);
    if (left_type->kind == _STRUCTURE) {
      FieldList* debugfl = left_type->structure.field;
      while (debugfl) {
        d(5);
        printf("name: %s, type: %s, at: %p\n", debugfl->var.symname,
               debugfl->var.variable.type.typename, debugfl);
        debugfl = debugfl->next;
      }
    }
    return 1;
  } else if (!strcmp(node->children[0]->name, "INT")) {
    left_type->kind = _INT;
    return 0;
  } else if (!strcmp(node->children[0]->name, "FLOAT")) {
    left_type->kind = _FLOAT;
    return 0;
  } else {
    assert(0);
  }
}

void Args(struct ast* node, FieldList* parameter) {
  Type exp_type;
  if (node->num == 1) {
    // Args -> Exp
    Exp(node->children[0], &exp_type);
    // 检查最后一个参数的类型与表达式的类型是否相容
    if (!type_equal(&exp_type, &parameter->var.variable.type)) {
      semantic_error(9, node->lineno, "functype", "var");
      return;
    }
  } else {
    // Args -> Exp COMMA Args
    if (parameter->next == NULL) {
      semantic_error(9, node->lineno, "functype", "var");
      return;
    }
    Exp(node->children[0], &exp_type);
    // 检查当前参数的类型与表达式的类型是否相容
    if (!type_equal(&exp_type, &parameter->var.variable.type)) {
      semantic_error(9, node->lineno, "functype", "var");
      return;
    }
    // 转移到下一个参数
    Args(node->children[2], parameter->next);
  }
}

void ID(struct ast* node, Symbol* sb) { strcpy(sb->symname, node->id_name); }

void eval_semantic(struct ast* root) {
  // eval_syntax_tree(root, 0);
  Program(root);
}

void semantic_error(int error_type, int lineno, char* msg, char* msg2) {
  printf("Error type %d at Line %d: ", error_type, lineno);
  switch (error_type) {
    case 1:
      printf("Undefined variable: \"%s\". \n", msg);
      break;
    case 2:
      printf("Undefined function: \"%s\". \n", msg);
      break;
    case 3:
      printf("Redefined variable: \"%s\". \n", msg);
      break;
    case 4:
      printf("Redefined function: \"%s\". \n", msg);
      break;
    case 5:
      printf("Type mismatched for assignment.  \n");
      break;
    case 6:
      printf("The left-hand side of an assignment must be a variable. \n");
      break;
    case 7:
      printf("Type mismatched for operands. \n");
      break;
    case 8:
      printf("Type mismatched for return. \n");
      break;
    case 9:
      printf("Function \"%s\" is not applicable for arguments \"%s\". \n", msg,
             msg2);
      break;
    case 10:
      if (msg)
        printf("\"%s\" is not an array. \n", msg);
      else
        printf("Unknown. \n");
      break;
    case 11:
      printf("\"%s\" is not a function. \n", msg);
      break;
    case 12:
      if (msg)
        printf("\"%s\" is not an integer. \n", msg);
      else
        printf("Unknown. \n");
      break;
    case 13:
      printf("Illegal use of \".\". \n");
      break;
    case 14:
      printf("There is no dominant name %s. \n", msg);
      break;
    case 15:
      printf(
          "Redefinition dominant name, or initiate in the structure: %s. "
          "\n",
          msg);
      break;
    case 16:
      printf("Structure %s is already exists. \n", msg);
      break;
    case 17:
      printf("Undefinition structure %s. \n", msg);
      break;
    case 18:
      printf("There is no definition of function %s. \n", msg);
      break;
    case 19:
      printf("Conflict definition of function %s. \n", msg);
      break;
    default:
      printf("default msg: %s. \n", msg);
      break;
  }
}
